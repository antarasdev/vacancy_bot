import asyncio

import aioschedule
from aiogram import F, Router, types
from aiogram.enums import ParseMode
from aiogram.exceptions import TelegramBadRequest
from aiogram.filters.command import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

from bot import bot
from my_bot.config import config
from my_bot.constants import EXAMPLE, RULES_TEXT, THREAD_KEYWORDS, START_MESSAGE
from my_bot.keyboards import main_keyboard, vacancy_time_keyboard, back_button

router = Router()

last_vacancy_sent = 0


class VacancyForm(StatesGroup):
    ConfirmVacancy = State()
    change_timestamp = State()


@router.message(Command("start"))
async def start(message: types.Message):
    text = START_MESSAGE
    await message.answer(text, reply_markup=main_keyboard(), parse_mode=ParseMode.MARKDOWN_V2)


@router.message(lambda message: message.text == 'üìë –ü—Ä–∏–º–µ—Ä\n–≤–∞–∫–∞–Ω—Å–∏–∏')
async def send_vacancy_example(message: types.Message):
    text = EXAMPLE
    await message.answer(text, parse_mode=ParseMode.MARKDOWN_V2)


@router.message(lambda message: message.text == 'üìî –ü—Ä–∞–≤–∏–ª–∞\n–ø—É–±–ª–∏–∫–∞—Ü–∏–∏')
async def send_rules(message: types.Message):
    text = RULES_TEXT
    await message.answer(text,  parse_mode=ParseMode.MARKDOWN_V2)


@router.message(lambda message: message.text == '‚úÖ–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –≤–∞–∫–∞–Ω—Å–∏—é')
async def publish_vacancy(message: types.Message, state: FSMContext):
    text = '–í—ã–±–µ—Ä–µ—Ç–µ —Å—Ä–æ–∫, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –≤–∞–∫–∞–Ω—Å–∏—é'
    await message.answer(text, reply_markup=vacancy_time_keyboard())
    await state.set_state(VacancyForm.change_timestamp)


@router.message(VacancyForm.change_timestamp)
async def process_vacancy(message: types.Message, state: FSMContext):
    if message.text == '–ù–∞–∑–∞–¥':
        await state.set_state(None)  # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –æ—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é
        await start(message)
    else:
        selected_time = message.text
        await state.update_data(selected_time=selected_time)
        await state.set_state(VacancyForm.ConfirmVacancy)
        text = f'–°—Ä–æ–∫ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: <i><b>{selected_time}</b></i>. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –≤–∞—à–µ–π –≤–∞–∫–∞–Ω—Å–∏–∏'
        await message.answer(text, reply_markup=back_button(), parse_mode=ParseMode.HTML)


@router.message(VacancyForm.ConfirmVacancy)
async def enter_vacancy_text(message: types.Message, state: FSMContext):
    if message.text == '–ù–∞–∑–∞–¥':
        await state.set_state(VacancyForm.change_timestamp)
        await publish_vacancy(message, state)
    else:
        global last_vacancy_sent
        current_time = asyncio.get_event_loop().time()
        data = message.text
        vacancy_parts = data.split('\n\n')
        selected_time = (await state.get_data()).get("selected_time")

        hashtags = [part for part in vacancy_parts if part.startswith("#")]
        name_organisation = [part for part in vacancy_parts if '–ù–∞–∑–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏' in part]
        responsibilities = [part for part in vacancy_parts if "–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∫–∞–Ω–¥–∏–¥–∞—Ç—É" in part]
        conditions = [part for part in vacancy_parts if "–£—Å–ª–æ–≤–∏—è —Ä–∞–±–æ—Ç—ã" in part]
        position = [part for part in vacancy_parts if "–î–æ–ª–∂–Ω–æ—Å—Ç—å" in part]
        salary = next((part for part in vacancy_parts if any(word in part.lower() for word in ["–∑–ø", "–æ–∫–ª–∞–¥"])), None)
        contacts = [part for part in vacancy_parts if "–ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ" in part]

        message_thread_id = None
        for thread_id, keywords in THREAD_KEYWORDS.items():
            for keyword in keywords:
                if keyword.lower() in data.lower() or any(
                        keyword.lower() in part.lower() for part in vacancy_parts):
                    message_thread_id = thread_id
                    break
            if message_thread_id:
                break

        if (message_thread_id and responsibilities and
                salary and position and hashtags and
                name_organisation and contacts):
            if current_time - last_vacancy_sent < 1800:  # 1800 seconds = 30 minutes
                await message.answer("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –≤–∞–∫–∞–Ω—Å–∏–∏ —á–∞—â–µ, —á–µ–º —Ä–∞–∑ –≤ 30 –º–∏–Ω—É—Ç.")
            else:
                formatted_vacancy = (
                    "\n\n".join(hashtags + name_organisation +
                                position + list(map(str, responsibilities)) +
                                conditions + [salary] + contacts)
                )
                vacancy = await bot.send_message(
                    chat_id=config.chat_id.get_secret_value(),
                    message_thread_id=message_thread_id,
                    text=formatted_vacancy
                )
                last_vacancy_sent = current_time
                if selected_time == '–ú–µ—Å—è—Ü':
                    aioschedule.every(4).weeks.do(delete_message, vacancy)
                elif selected_time == '3 –ù–µ–¥–µ–ª–∏':
                    aioschedule.every(3).weeks.do(delete_message, vacancy)
                elif selected_time == '2 –ù–µ–¥–µ–ª–∏':
                    aioschedule.every(2).weeks.do(delete_message, vacancy)
                else:
                    aioschedule.every(1).weeks.do(delete_message, vacancy)
                await state.clear()
                vacancy_link = f"{config.link.get_secret_value()}{message_thread_id}/{vacancy.message_id}"
                await message.answer(f"–í–∞—à–∞ –≤–∞–∫–∞–Ω—Å–∏—è —É—Å–ø–µ—à–Ω–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞üéâ\n\n"
                                     f"[–ú–æ–∂–µ—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –µ—ë –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ]({vacancy_link})",
                                     reply_markup=main_keyboard(),
                                     parse_mode=ParseMode.MARKDOWN_V2)
        else:
            await message.answer(
                "–í–∞–∫–∞–Ω—Å–∏—è –Ω–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞–∫–∞–Ω—Å–∏—é –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ.",
                reply_markup=main_keyboard()
            )


async def delete_message(vacancy):
    chat_id = vacancy.chat.id
    message_id = vacancy.message_id
    try:
        await bot.delete_message(chat_id=chat_id, message_id=message_id)
    except TelegramBadRequest as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")


@router.message()
async def message_handler(message: types.Message):
    text = "–ß—Ç–æ–±—ã –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –≤–∞–∫–∞–Ω—Å–∏—é, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É '‚úÖ–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –≤–∞–∫–∞–Ω—Å–∏—é'"
    await message.answer(text, reply_markup=main_keyboard())
